The system has been modelled using controllers for each of the components. To avoid duplication of code, the two input stacks have the same controller code, and it is just that the two controllers are distinguished by means of input stack IDs. Likewise, the controllers for both output stacks, the controllers for the two outer robots, and the controllers for the two airlocks have the same code in each case, and the respective controllers are differentiated using output stack IDs, robot IDs, and airlock IDs respectively.

Each controller has a set of states defined by variables as required to determine the uniqueness of the states. The controller communicates with one or more controllers and exchanges state information so as to make transitions by means of actions based on the state of the other concerned controllers' states. For instance, the outer robot controller changes its state from one having \textit{hasWafer} as \texttt{true} to one having it as \texttt{false} based on the airlock controller's state (to get its sensor information) after the robot drops its wafer.

Since there are lots of "IDs" involved, lots of maps have been used to \textit{match} the various IDs across controllers (for instance, when referring to interactions between robot 1 and airlock 1, the IDs will always be matched as R1 -> A1 or A1 -> R1.)

The \texttt{mcrl22lps} command is used to generate the lps for the mclr2 code, and is translated to an lts using the \texttt{lps2lts} command. Given the number of parallel components, it is difficult to get a good understanding of the system based on its LTS, and hence the \texttt{ltsview} command is used to visualize the system and its states, and most importantly, to ensure that no deadlocks are present. 